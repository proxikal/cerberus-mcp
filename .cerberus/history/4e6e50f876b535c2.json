{
  "timestamp": "2026-01-09T21:18:59.655326",
  "operation_type": "edit",
  "files": [
    "src/cerberus/mutation/facade.py"
  ],
  "reverse_patches": [
    {
      "file_path": "src/cerberus/mutation/facade.py",
      "original_content": "\"\"\"\nMutationFacade: Orchestrate surgical editing operations.\n\nPhase 11: Main entry point for edit/insert/delete operations.\n\"\"\"\n\nfrom pathlib import Path\nfrom typing import Optional, Dict, Any, List\n\nfrom cerberus.logging_config import logger\nfrom cerberus.storage.sqlite_store import SQLiteIndexStore\nfrom cerberus.schemas import MutationResult, SymbolLocation, EditOperation, BatchEditResult\n\nfrom .locator import SymbolLocator\nfrom .editor import CodeEditor\nfrom .formatter import CodeFormatter\nfrom .validator import CodeValidator\nfrom .import_manager import ImportManager\nfrom .ledger import DiffLedger\nfrom .guard import SymbolGuard\nfrom .undo import UndoStack\nfrom .style_guard import StyleGuard\nfrom .config import MUTATION_CONFIG\n\n\nclass MutationFacade:\n    \"\"\"\n    Main facade for code mutation operations.\n\n    Orchestrates the complete pipeline:\n    1. Locate symbol (SymbolLocator)\n    2. Format code (CodeFormatter)\n    3. Analyze dependencies (ImportManager)\n    4. Create backup (CodeEditor)\n    5. Replace/insert/delete (CodeEditor)\n    6. Inject imports (ImportManager)\n    7. Format file (CodeFormatter)\n    8. Validate (CodeValidator)\n    9. Write if valid (CodeEditor)\n    10. Record metrics (DiffLedger)\n    \"\"\"\n\n    def __init__(\n        self,\n        store: SQLiteIndexStore,\n        config: Optional[Dict[str, Any]] = None\n    ):\n        \"\"\"\n        Initialize mutation facade.\n\n        Args:\n            store: SQLite index store for symbol lookups\n            config: Optional config overrides\n        \"\"\"\n        self.store = store\n        self.config = {**MUTATION_CONFIG, **(config or {})}\n\n        # Initialize components\n        self.locator = SymbolLocator(store)\n        self.editor = CodeEditor(self.config)\n        self.formatter = CodeFormatter(self.config)\n        self.validator = CodeValidator(store)\n        self.import_manager = ImportManager(store)\n        self.ledger = DiffLedger(self.config.get(\"ledger_path\"))\n        self.guard = SymbolGuard(store, self.config.get(\"index_path\", \"cerberus.db\"))\n        self.undo = UndoStack(self.config.get(\"undo_history_dir\", \".cerberus/history\"))\n        self.style_guard = StyleGuard()\n\n        logger.debug(\"MutationFacade initialized\")\n\n    def edit_symbol(\n        self,\n        file_path: str,\n        symbol_name: str,\n        new_code: str,\n        symbol_type: Optional[str] = None,\n        parent_class: Optional[str] = None,\n        dry_run: bool = False,\n        auto_format: bool = True,\n        auto_imports: bool = True\n    ) -> MutationResult:\n        \"\"\"\n        Edit a symbol by name.\n\n        Args:\n            file_path: Path to source file\n            symbol_name: Symbol name to edit\n            new_code: New code implementation\n            symbol_type: Optional symbol type filter\n            parent_class: Optional parent class for methods\n            dry_run: If True, validate but don't write\n            auto_format: If True, auto-format after edit\n            auto_imports: If True, auto-inject missing imports\n\n        Returns:\n            MutationResult with status and metrics\n        \"\"\"\n        logger.info(f\"Editing symbol '{symbol_name}' in {file_path}\")\n\n        # Phase 12: Read original content for diff generation\n        original_content = \"\"\n        try:\n            with open(file_path, 'r', encoding='utf-8') as f:\n                original_content = f.read()\n        except Exception as e:\n            logger.warning(f\"Failed to read original content for diff: {e}\")\n\n        # 1. Locate symbol\n        location = self.locator.locate_symbol(\n            file_path,\n            symbol_name,\n            symbol_type,\n            parent_class\n        )\n\n        if not location:\n            return MutationResult(\n                success=False,\n                operation=\"edit\",\n                file_path=file_path,\n                symbol_name=symbol_name,\n                lines_changed=0,\n                lines_total=0,\n                write_efficiency=0.0,\n                tokens_saved=0,\n                validation_passed=False,\n                errors=[f\"Symbol '{symbol_name}' not found in {file_path}\"]\n            )\n\n        # 2. Format new code to match indentation\n        if auto_format:\n            new_code = self.formatter.format_code_block(\n                new_code,\n                location.indentation_level,\n                file_path\n            )\n\n        # 3. Analyze dependencies (placeholder for now)\n        required_imports = []\n        if auto_imports:\n            required_imports = self.import_manager.analyze_dependencies(\n                new_code,\n                location.language\n            )\n\n        # 4-5. Replace symbol (includes backup) - skip if dry_run\n        if dry_run:\n            # Dry run: just validate syntax and return\n            validation_passed, errors, warnings = self.validator.dry_run_validation(\n                file_path,\n                new_code,\n                location.language\n            )\n            return MutationResult(\n                success=validation_passed,\n                operation=\"edit\",\n                file_path=file_path,\n                symbol_name=symbol_name,\n                lines_changed=0,\n                lines_total=0,\n                write_efficiency=0.0,\n                tokens_saved=0,\n                validation_passed=validation_passed,\n                errors=errors,\n                warnings=warnings,\n                backup_path=None\n            )\n\n        # Normal mode: perform the edit\n        success, backup_path = self.editor.replace_symbol(location, new_code)\n\n        if not success:\n            return MutationResult(\n                success=False,\n                operation=\"edit\",\n                file_path=file_path,\n                symbol_name=symbol_name,\n                lines_changed=0,\n                lines_total=0,\n                write_efficiency=0.0,\n                tokens_saved=0,\n                validation_passed=False,\n                errors=[\"Failed to write changes\"],\n                backup_path=backup_path\n            )\n\n        # Read modified content for validation\n        try:\n            with open(file_path, 'r', encoding='utf-8') as f:\n                modified_content = f.read()\n        except Exception as e:\n            return MutationResult(\n                success=False,\n                operation=\"edit\",\n                file_path=file_path,\n                symbol_name=symbol_name,\n                lines_changed=0,\n                lines_total=0,\n                write_efficiency=0.0,\n                tokens_saved=0,\n                validation_passed=False,\n                errors=[f\"Failed to read modified file: {e}\"],\n                backup_path=backup_path\n            )\n\n        # 6. Inject imports if needed\n        if auto_imports and required_imports:\n            modified_content = self.import_manager.inject_imports(\n                file_path,\n                modified_content,\n                required_imports,\n                location.language\n            )\n\n        # 7. Format file (optional)\n        if auto_format and not dry_run:\n            self.formatter.format_file(file_path, location.language)\n\n        # 8. Validate\n        validation_passed, errors, warnings = self.validator.dry_run_validation(\n            file_path,\n            modified_content,\n            location.language\n        )\n\n        # Calculate metrics\n        lines_total = len(modified_content.split('\\n'))\n        lines_changed = location.end_line - location.start_line + 1\n        write_efficiency = lines_changed / lines_total if lines_total > 0 else 0.0\n        tokens_saved = (lines_total - lines_changed) * 4\n\n        # 10. Record metrics\n        if self.config.get(\"ledger_enabled\") and not dry_run:\n            self.ledger.record_mutation(\n                \"edit\",\n                file_path,\n                lines_changed,\n                lines_total\n            )\n\n        # Phase 12: Generate unified diff\n        diff = None\n        if original_content and not dry_run:\n            try:\n                diff = self.editor.generate_unified_diff(\n                    file_path,\n                    original_content,\n                    modified_content\n                )\n            except Exception as e:\n                logger.warning(f\"Failed to generate diff: {e}\")\n\n        return MutationResult(\n            success=validation_passed and success,\n            operation=\"edit\",\n            file_path=file_path,\n            symbol_name=symbol_name,\n            lines_changed=lines_changed,\n            lines_total=lines_total,\n            write_efficiency=write_efficiency,\n            tokens_saved=tokens_saved,\n            validation_passed=validation_passed,\n            errors=errors,\n            warnings=warnings,\n            backup_path=backup_path,\n            diff=diff\n        )\n\n    def insert_symbol(\n        self,\n        file_path: str,\n        parent_symbol: str,\n        new_code: str,\n        after_symbol: Optional[str] = None,\n        before_symbol: Optional[str] = None,\n        dry_run: bool = False\n    ) -> MutationResult:\n        \"\"\"\n        Insert new code into a file.\n        Phase 12: Complete CRUD implementation.\n\n        Args:\n            file_path: Path to file\n            parent_symbol: Parent symbol (class) to insert into\n            new_code: Code to insert\n            after_symbol: Insert after this symbol\n            before_symbol: Insert before this symbol\n            dry_run: If True, validate but don't write\n\n        Returns:\n            MutationResult with status and metrics\n        \"\"\"\n        logger.info(f\"Inserting code into '{parent_symbol}' in {file_path}\")\n\n        # Phase 12: Read original content for diff generation\n        original_content = \"\"\n        try:\n            with open(file_path, 'r', encoding='utf-8') as f:\n                original_content = f.read()\n        except Exception as e:\n            logger.warning(f\"Failed to read original content for diff: {e}\")\n\n        # Locate parent symbol\n        parent_location = self.locator.locate_symbol(\n            file_path,\n            parent_symbol,\n            symbol_type=\"class\"  # Most common case\n        )\n\n        if not parent_location:\n            return MutationResult(\n                success=False,\n                operation=\"insert\",\n                file_path=file_path,\n                symbol_name=parent_symbol,\n                lines_changed=0,\n                lines_total=0,\n                write_efficiency=0.0,\n                tokens_saved=0,\n                validation_passed=False,\n                errors=[f\"Parent symbol '{parent_symbol}' not found in {file_path}\"]\n            )\n\n        # Determine insertion point\n        byte_offset = parent_location.end_byte  # Default: end of parent\n\n        if after_symbol:\n            after_location = self.locator.locate_symbol(\n                file_path,\n                after_symbol,\n                parent_class=parent_symbol\n            )\n            if after_location:\n                byte_offset = after_location.end_byte\n            else:\n                logger.warning(f\"after_symbol '{after_symbol}' not found, using default position\")\n\n        elif before_symbol:\n            before_location = self.locator.locate_symbol(\n                file_path,\n                before_symbol,\n                parent_class=parent_symbol\n            )\n            if before_location:\n                byte_offset = before_location.start_byte\n            else:\n                logger.warning(f\"before_symbol '{before_symbol}' not found, using default position\")\n\n        # Format new code with proper indentation\n        indentation_level = parent_location.indentation_level + 1  # One level deeper than parent\n        new_code_formatted = self.formatter.format_code_block(\n            new_code,\n            indentation_level,\n            file_path\n        )\n\n        # Add newlines around the insertion\n        new_code_formatted = \"\\n\" + new_code_formatted + \"\\n\"\n\n        # Perform insertion if not dry run\n        if not dry_run:\n            success, backup_path = self.editor.insert_symbol(\n                file_path,\n                byte_offset,\n                new_code_formatted\n            )\n        else:\n            success, backup_path = True, None\n\n        if not success and not dry_run:\n            return MutationResult(\n                success=False,\n                operation=\"insert\",\n                file_path=file_path,\n                symbol_name=parent_symbol,\n                lines_changed=0,\n                lines_total=0,\n                write_efficiency=0.0,\n                tokens_saved=0,\n                validation_passed=False,\n                errors=[\"Failed to insert code\"],\n                backup_path=backup_path\n            )\n\n        # Read modified content\n        try:\n            with open(file_path, 'r', encoding='utf-8') as f:\n                modified_content = f.read()\n        except Exception as e:\n            return MutationResult(\n                success=False,\n                operation=\"insert\",\n                file_path=file_path,\n                symbol_name=parent_symbol,\n                lines_changed=0,\n                lines_total=0,\n                write_efficiency=0.0,\n                tokens_saved=0,\n                validation_passed=False,\n                errors=[f\"Failed to read modified file: {e}\"],\n                backup_path=backup_path if not dry_run else None\n            )\n\n        # Validate\n        validation_passed, errors, warnings = self.validator.dry_run_validation(\n            file_path,\n            modified_content if not dry_run else original_content + new_code_formatted,\n            parent_location.language\n        )\n\n        # Calculate metrics\n        lines_total = len(modified_content.split('\\n'))\n        lines_changed = len(new_code_formatted.split('\\n'))\n        write_efficiency = lines_changed / lines_total if lines_total > 0 else 0.0\n        tokens_saved = (lines_total - lines_changed) * 4\n\n        # Record metrics\n        if self.config.get(\"ledger_enabled\") and not dry_run:\n            self.ledger.record_mutation(\n                \"insert\",\n                file_path,\n                lines_changed,\n                lines_total\n            )\n\n        # Phase 12: Generate unified diff\n        diff = None\n        if original_content and not dry_run:\n            try:\n                diff = self.editor.generate_unified_diff(\n                    file_path,\n                    original_content,\n                    modified_content\n                )\n            except Exception as e:\n                logger.warning(f\"Failed to generate diff: {e}\")\n\n        return MutationResult(\n            success=validation_passed and success,\n            operation=\"insert\",\n            file_path=file_path,\n            symbol_name=parent_symbol,\n            lines_changed=lines_changed,\n            lines_total=lines_total,\n            write_efficiency=write_efficiency,\n            tokens_saved=tokens_saved,\n            validation_passed=validation_passed,\n            errors=errors,\n            warnings=warnings,\n            backup_path=backup_path if not dry_run else None,\n            diff=diff\n        )\n\n    def delete_symbol(\n        self,\n        file_path: str,\n        symbol_name: str,\n        symbol_type: Optional[str] = None,\n        parent_class: Optional[str] = None,\n        dry_run: bool = False,\n        keep_decorators: bool = False,\n        force: bool = False\n    ) -> MutationResult:\n        \"\"\"\n        Delete a symbol from file.\n\n        Args:\n            file_path: Path to file\n            symbol_name: Symbol to delete\n            symbol_type: Optional symbol type filter\n            parent_class: Optional parent class for methods\n            dry_run: If True, validate but don't write\n            keep_decorators: If True, keep decorators\n            force: If True, bypass reference protection (Phase 12.5)\n\n        Returns:\n            MutationResult with status and metrics\n        \"\"\"\n        logger.info(f\"Deleting symbol '{symbol_name}' from {file_path}\")\n\n        # Phase 12: Read original content for diff generation\n        original_content = \"\"\n        try:\n            with open(file_path, 'r', encoding='utf-8') as f:\n                original_content = f.read()\n        except Exception as e:\n            logger.warning(f\"Failed to read original content for diff: {e}\")\n\n        # Locate symbol\n        location = self.locator.locate_symbol(\n            file_path,\n            symbol_name,\n            symbol_type,\n            parent_class\n        )\n\n        if not location:\n            return MutationResult(\n                success=False,\n                operation=\"delete\",\n                file_path=file_path,\n                symbol_name=symbol_name,\n                lines_changed=0,\n                lines_total=0,\n                write_efficiency=0.0,\n                tokens_saved=0,\n                validation_passed=False,\n                errors=[f\"Symbol '{symbol_name}' not found\"]\n            )\n\n        # Phase 12.5: Symbol Guard - Check for references before deletion\n        if not dry_run:\n            allowed, guard_error, references = self.guard.check_references(\n                symbol_name,\n                file_path,\n                force\n            )\n\n            if not allowed:\n                return MutationResult(\n                    success=False,\n                    operation=\"delete\",\n                    file_path=file_path,\n                    symbol_name=symbol_name,\n                    lines_changed=0,\n                    lines_total=0,\n                    write_efficiency=0.0,\n                    tokens_saved=0,\n                    validation_passed=False,\n                    errors=[guard_error],\n                    warnings=[f\"Found {len(references)} reference(s) to this symbol\"]\n                )\n\n        # Delete symbol\n        if not dry_run:\n            success, backup_path = self.editor.delete_symbol(location, keep_decorators)\n        else:\n            success, backup_path = True, None\n\n        # Read modified content\n        try:\n            with open(file_path, 'r', encoding='utf-8') as f:\n                modified_content = f.read()\n        except Exception as e:\n            return MutationResult(\n                success=False,\n                operation=\"delete\",\n                file_path=file_path,\n                symbol_name=symbol_name,\n                lines_changed=0,\n                lines_total=0,\n                write_efficiency=0.0,\n                tokens_saved=0,\n                validation_passed=False,\n                errors=[f\"Failed to read file: {e}\"]\n            )\n\n        # Validate\n        validation_passed, errors, warnings = self.validator.dry_run_validation(\n            file_path,\n            modified_content,\n            location.language\n        )\n\n        # Calculate metrics\n        lines_total = len(modified_content.split('\\n'))\n        lines_changed = location.end_line - location.start_line + 1\n        write_efficiency = lines_changed / lines_total if lines_total > 0 else 0.0\n        tokens_saved = (lines_total - lines_changed) * 4\n\n        # Record metrics\n        if self.config.get(\"ledger_enabled\") and not dry_run:\n            self.ledger.record_mutation(\n                \"delete\",\n                file_path,\n                lines_changed,\n                lines_total\n            )\n\n        # Phase 12: Generate unified diff\n        diff = None\n        if original_content and not dry_run:\n            try:\n                diff = self.editor.generate_unified_diff(\n                    file_path,\n                    original_content,\n                    modified_content\n                )\n            except Exception as e:\n                logger.warning(f\"Failed to generate diff: {e}\")\n\n        return MutationResult(\n            success=validation_passed and success,\n            operation=\"delete\",\n            file_path=file_path,\n            symbol_name=symbol_name,\n            lines_changed=lines_changed,\n            lines_total=lines_total,\n            write_efficiency=write_efficiency,\n            tokens_saved=tokens_saved,\n            validation_passed=validation_passed,\n            errors=errors,\n            warnings=warnings,\n            backup_path=backup_path,\n            diff=diff\n        )\n\n    def batch_edit(\n        self,\n        operations: List[EditOperation],\n        verify_command: Optional[str] = None,\n        preview: bool = False\n    ) -> BatchEditResult:\n        \"\"\"\n        Execute multiple edit operations atomically.\n        Phase 12: Atomic multi-file transactions with rollback on failure.\n        Phase 12.5: Preview mode for dry-run visualization.\n\n        Args:\n            operations: List of edit operations to perform\n            verify_command: Optional shell command to verify changes (e.g., \"pytest\")\n            preview: If True, run in dry-run mode without writing files\n\n        Returns:\n            BatchEditResult with all mutation results and rollback status\n        \"\"\"\n        logger.info(f\"Starting batch edit with {len(operations)} operations\")\n\n        results: List[MutationResult] = []\n        backup_paths: List[str] = []\n        operations_completed = 0\n        all_errors: List[str] = []\n\n        # Phase 12.5: Capture original file content for undo\n        original_contents: Dict[str, str] = {}\n        affected_files = set(op.file_path for op in operations)\n\n        for file_path in affected_files:\n            try:\n                with open(file_path, 'r', encoding='utf-8') as f:\n                    original_contents[file_path] = f.read()\n            except Exception as e:\n                logger.warning(f\"Could not capture original content for {file_path}: {e}\")\n\n        # Group operations by file to process them in sequence per file\n        from collections import defaultdict\n        ops_by_file: Dict[str, List[EditOperation]] = defaultdict(list)\n        for op in operations:\n            ops_by_file[op.file_path].append(op)\n\n        try:\n            # Process each file's operations\n            for file_path, file_ops in ops_by_file.items():\n                logger.info(f\"Processing {len(file_ops)} operations for {file_path}\")\n\n                # Execute operations for this file\n                for op in file_ops:\n                    if op.operation == \"edit\":\n                        result = self.edit_symbol(\n                            file_path=op.file_path,\n                            symbol_name=op.symbol_name,\n                            new_code=op.new_code or \"\",\n                            symbol_type=op.symbol_type,\n                            parent_class=op.parent_class,\n                            dry_run=preview,\n                            auto_format=op.auto_format,\n                            auto_imports=op.auto_imports\n                        )\n                    elif op.operation == \"insert\":\n                        result = self.insert_symbol(\n                            file_path=op.file_path,\n                            parent_symbol=op.parent_symbol or op.symbol_name,\n                            new_code=op.new_code or \"\",\n                            after_symbol=op.after_symbol,\n                            before_symbol=op.before_symbol,\n                            dry_run=preview\n                        )\n                    elif op.operation == \"delete\":\n                        result = self.delete_symbol(\n                            file_path=op.file_path,\n                            symbol_name=op.symbol_name,\n                            symbol_type=op.symbol_type,\n                            parent_class=op.parent_class,\n                            dry_run=preview\n                        )\n                    else:\n                        result = MutationResult(\n                            success=False,\n                            operation=op.operation,\n                            file_path=op.file_path,\n                            symbol_name=op.symbol_name,\n                            lines_changed=0,\n                            lines_total=0,\n                            write_efficiency=0.0,\n                            tokens_saved=0,\n                            validation_passed=False,\n                            errors=[f\"Unknown operation: {op.operation}\"]\n                        )\n\n                    results.append(result)\n\n                    if not result.success:\n                        error_msg = f\"Operation failed: {op.operation} on {op.symbol_name} in {op.file_path}\"\n                        all_errors.append(error_msg)\n                        logger.error(error_msg)\n                        raise RuntimeError(error_msg)\n\n                    # Track backups for rollback\n                    if result.backup_path:\n                        backup_paths.append(result.backup_path)\n\n                    operations_completed += 1\n\n            # Phase 12: Run verify command if provided\n            if verify_command:\n                logger.info(f\"Running verification command: {verify_command}\")\n                import subprocess\n                result_code = subprocess.run(\n                    verify_command,\n                    shell=True,\n                    capture_output=True,\n                    text=True\n                )\n\n                if result_code.returncode != 0:\n                    error_msg = f\"Verification failed (exit code {result_code.returncode})\"\n                    all_errors.append(error_msg)\n                    all_errors.append(f\"Stdout: {result_code.stdout}\")\n                    all_errors.append(f\"Stderr: {result_code.stderr}\")\n                    logger.error(error_msg)\n                    raise RuntimeError(error_msg)\n\n            # Phase 12.5: Record transaction for undo (skip in preview mode)\n            if not preview:\n                reverse_patches = []\n                for file_path, original_content in original_contents.items():\n                    reverse_patches.append({\n                        \"file_path\": file_path,\n                        \"original_content\": original_content\n                    })\n\n                if reverse_patches:\n                    try:\n                        operation_types = list(set(op.operation for op in operations))\n                        operation_type = operation_types[0] if len(operation_types) == 1 else \"batch\"\n\n                        transaction_id = self.undo.record_transaction(\n                            operation_type=operation_type,\n                            files=list(affected_files),\n                            reverse_patches=reverse_patches,\n                            metadata={\n                                \"operations_count\": len(operations),\n                                \"verify_command\": verify_command\n                            }\n                        )\n                        logger.info(f\"Recorded undo transaction: {transaction_id}\")\n                    except Exception as e:\n                        logger.warning(f\"Failed to record undo transaction: {e}\")\n\n            # Success!\n            logger.info(f\"Batch edit completed successfully: {operations_completed}/{len(operations)}\")\n            return BatchEditResult(\n                success=True,\n                operations_completed=operations_completed,\n                operations_total=len(operations),\n                results=results,\n                errors=[],\n                rolled_back=False\n            )\n\n        except Exception as e:\n            # Rollback all changes\n            logger.error(f\"Batch edit failed, rolling back changes: {e}\")\n            rollback_success = True\n\n            for backup_path in backup_paths:\n                try:\n                    # Extract original file path from backup path\n                    # Backup format: .cerberus_backups/filename.timestamp.backup\n                    import re\n                    from pathlib import Path\n\n                    backup_name = Path(backup_path).name\n                    # Remove timestamp and .backup extension\n                    match = re.match(r\"(.+)\\.\\d{8}_\\d{6}\\.backup$\", backup_name)\n                    if match:\n                        original_name = match.group(1)\n                        # Find the file in the results to get full path\n                        for mutation_result in results:\n                            if Path(mutation_result.file_path).name == original_name:\n                                target_path = mutation_result.file_path\n                                success = self.editor._restore_backup(backup_path, target_path)\n                                if not success:\n                                    rollback_success = False\n                                    logger.error(f\"Failed to restore backup: {backup_path}\")\n                                break\n                except Exception as rollback_error:\n                    rollback_success = False\n                    logger.error(f\"Failed to rollback {backup_path}: {rollback_error}\")\n\n            return BatchEditResult(\n                success=False,\n                operations_completed=operations_completed,\n                operations_total=len(operations),\n                results=results,\n                errors=all_errors,\n                rolled_back=rollback_success\n            )\n"
    }
  ],
  "metadata": {
    "operations_count": 1,
    "verify_command": null
  }
}